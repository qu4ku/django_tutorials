[
{
  "model": "blog.article",
  "pk": 1,
  "fields": {
    "title": "C++ and the Culture of Complexity",
    "slug": "cpp-and-the-culture-of-complexity",
    "body": "I am a longtime user of C++, and I have been an author and speaker in the C++ community for many years. Yet, the number-crunching backend of GreaterThanZero is written in Java and not in C++. Does that mean I have joined the ranks of those who have turned their backs on C++? No it does not, and I can prove it: search for \u201cC++ auto and decltype\u201d, and you\u2019ll find that the top result is an article that I wrote only a few weeks ago. The decision to implement the math backend of GreaterThanZero in Java was driven by other considerations, primarily the appeal of Google App Engine as a hosting platform. [1]\r\n\r\nWhile I was writing the JavaScript and Java code for GreaterThanZero, I often found myself thinking, \u201cWow, this is really easy. Anybody could do this.\u201d And then, I am ashamed to admit, I was disappointed. I was disappointed that there was no opportunity for me to prove that I was smarter than the next guy. I actually had to comfort myself with the thought that the mathematics that I was implementing was non-trivial.\r\n\r\nTrying to impress people with the complexity of your code rather than with your software is a sign of immaturity and bad engineering. And I\u2019ve been doing it. Needless to say, this is something that I need to work on. I am not going to blame my own weaknesses and character flaws on others. However, I think it is fair to say that the bad habit of wanting to impress others with the complexity of one\u2019s code can develop and flourish only in a \u201cculture of complexity,\u201d a culture in which complex and hard-to-understand code is at least tolerated, if not admired and encouraged. While I don\u2019t know how widespread it really is, I know from my own experience that such a culture of complexity has afflicted part of the C++ community.\r\n\r\nI believe that if you want to fix a problem, you have to first understand its origins. Therefore, I will attempt to throw some light on the penchant for complexity that one encounters in parts of the C++ community by going back to the roots of C++ and object oriented programming.\r\n\r\nThere is a widespread consensus that the first object-oriented language was Simula 67. Earlier developments that contributed to the emergence of the OO paradigm took place in the Lisp-dominated environment at MIT, in particular, in the artificial intelligence group. [2] I don\u2019t know to what extent the creators of Simula 67 were influenced by what was happening at MIT. However, intentionally or not, Simula 67 did exhibit some continuity to Lisp by embracing reference semantics and garbage collection (more about that later).\r\n\r\nHow does C++ fit into this picture? As of this writing, the Wikipedia article on Simula states that \u201cThe creator of C++, Bjarne Stroustrup, has acknowledged that Simula 67 was the greatest influence on him to develop C++, to bring the kind of productivity enhancements offered by Simula to the raw computational speed offered by lower level languages like BCPL.\u201d [3] [4]\r\n\r\nIt is probably fair to call the emergence of Simula 67 and the OO paradigm an example of an innovative, if not revolutionary concept that grew organically out of existing, tried and true practices. I submit the fact that Lisp used reference semantics and garbage collection as evidence. In my opinion, the way that C++ combines the OO paradigm with the efficiency and low-level control that C affords is a different kind of endeavor. Trying to combine things that evolved independently of each other in the hopes of getting the best of both worlds is, in my opinion, an experiment. I am not implying any criticism when I say that; on the contrary, I believe that human curiosity and the everlasting search for optimal solutions dictate that such an experiment be conducted.\r\n\r\nThe experiment that is C++ has not failed. Way too many people have written way too much amazing and useful software in C++ for anybody to denounce C++ as a failure. [5] On the other hand, it is my opinion that the experiment is not a complete success either, in the sense that one could say, this works like a charm, it\u2019s as if OO and C\u2019s low-level control were made for each other. It appears to me that there is a noticeable amount of incompatibility and incongruity there, which manifests itself in two ways:\r\n\r\nThe C++ programmer has to spend a considerable amount of effort to no other end than to make the language work.\r\nThe evolution of C++ is to a noticeable extent driven by the need to deal with the consequences of the incompatibilities and incongruities at the core of the language.\r\nTo see some evidence of this, consider any mainstream OO programming language other than C++ and Objective C. Think Java or C#. Consider this line:\r\n\r\nx = y;\r\nWhat does that do? It makes the variable x refer to the object that y is referring to, and it lets the garbage collector deal with the repercussions for the object that x was previously referring to. That\u2019s called reference semantics, and it also kicks in during function argument passing. [6]\r\n\r\nNow consider that same line in C++, and suppose that x and y are objects of user-defined type. What does the line do? Well, we don\u2019t know, of course, without studying the source code of the user-defined type, as the copy assignment operator may have been overloaded. But there is a default behavior, and that is, roughly speaking, that the object referred to by x is put in the same state as the object referred to by y. Technically, this is achieved by applying the copy assignment operator recursively to the members of the object until basic types like int are encountered, in which case a good old value assignment takes place [7] [8]. That\u2019s called value semantics, although I would prefer the term state semantics: objects do not have a value, they have state, and that\u2019s what\u2019s being transferred here.\r\n\r\nFew people would disagree that assignment between variables is part of the design of a language. In C++, assignment between variables of user-defined type involves making a copy of an object. But experience shows that making a copy of an object is hard. The following excerpt from the comp.lang.lisp FAQ page sums it up nicely: \u201cQ: Why isn\u2019t there a DEEP-COPY function in the language? A: Copying an arbitrary structure or object [sic!] needs context to determine what the correct copy is.\u201d In C++, this is exacerbated by the fact that making a copy of an object encounters technical problems such as dealing with C-style pointers as class members. [9] I believe that this is evidence to support my conjecture 1 above: the C++ programmer has to spend effort to ensure that a language feature as basic as assignment between variables works properly. This is just one example; I am prepared to give more.\r\n\r\nFor evidence supporting my conjecture 2 above, I ask you to consider rvalue references. Rvalue references provide move semantics, and they solve the perfect forwarding problem. Neither the performance issue that move semantics address nor the perfect forwarding problem exist in classic OO languages that use reference semantics and garbage collection for user-defined types. C++ is solving its own specific problems here, and it does so in a way that is not transparent to the application programmer: rvalue references have increased the surface area of the language as seen by the application programmer. Again, this is merely one example of evidence for my conjecture; I am prepared to give more.\r\n\r\nIt has been said that there is such a thing as the DNA of a company or organization. If it is true that programming languages have DNAs as well, then it appears to me that C++ has built into its DNA\r\n\r\na willingness to let issues that are rooted in the internals of the language and its design spill into programmers\u2019 everyday lives,\r\na tendency towards experimentation, a tendency to focus on the immediate benefit of a feature and fix problems later, and\r\na tendency to increase the volume and surface area of the language lightly, with little regard for the combinatorial complexity that arises from the interaction of features.\r\nAgain, not to make excuses for my inexcusable behavior of writing complicated and experimental code out of vanity, but I honestly feel that I have been tempted to do so by a culture that was indifferent to gratuitous complexity at best, encouraging it at worst. I believe that the stewards of a language that demands so much from its users, and gives them so much opportunity to go overboard with experimentation and complexity, have an obligation to make a strong effort at creating a culture of simplicity. To be perfectly honest, I don\u2019t see that effort at all. In view of the competition from languages like Go, this makes me pessimistic about the future of C++.",
    "date": "2018-01-31T14:04:56.834Z",
    "thumb": "default.png"
  }
},
{
  "model": "blog.article",
  "pk": 2,
  "fields": {
    "title": "Andrew Ng officially launches his $175M AI Fund",
    "slug": "andrew-ng-officially-launches-his-175m-ai-fund",
    "body": "As the founder of the Google Brain deep learning project and co-founder of Coursera, Andrew Ng was one of the most recognizable names in the machine learning community when he became Baidu\u2019s chief scientist in 2014. He left there in early 2017 and quickly launched a number of new AI projects, including the Deeplearning.ai course and Landing.ai, a project that aims to bring AI to manufacturing companies. It turns out that what he was really working on, though, was his AI Fund (which isn\u2019t really a fund in the traditional sense), which we first reported last summer.\r\n\r\nThis fund is now official. Ng has raised more than $175 million for the fund, but this isn\u2019t going to be a traditional venture fund. Instead, Ng and his team will use the money to initiate new businesses and build new companies in a model that\u2019s maybe more akin to the early Betaworks model. The investors in this new fund include NEA, Sequoia, Greylock Partners and the SoftBank Group. Ng is leading the fund as a general partner, with Eva Wang serving as partner and COO and Steven Syverud also joining as a partner.\r\n\r\n\u201cOne of my philosophies of building companies is the importance of velocity,\u201d Ng told me. In his view, AI businesses are also different from regular startups because you generally get a closed feedback loop that allows you to quickly see what works (and what doesn\u2019t). \u201cDepending on the vertical, I really value the ability to inject velocity into that positive feedback loop,\u201d said Ng. He also believes that building AI businesses is a more repeatable process than building other startups. Indeed, he stressed that at Baidu, his job was essentially to build a series of teams for building potential AI-related businesses.\r\n\r\nFor the fund, this means that Ng plans to create teams that can then immediately start experimenting with new ideas. And because the team is already funded, there\u2019s no need to worry and get distracted about raising funds.\r\n\r\nAs for raising his own fund, Ng told me he was able to raise the money pretty quickly. \u201cThere is so much capital globally that wants to go into AI, so frankly, our fundraising process was very painless,\u201d he told me. \u201cIf you see this wave of value creation coming, there aren\u2019t a lot of investment vehicles for them. If you look around the world, there are only some investors to really build AI businesses.\u201d\r\n\r\nNg isn\u2019t yet talking about what new businesses we should expect from his fund, but the first company to come out of the fund is, unsurprisingly, Landing.ai, and he told me there are currently two more projects in the works.\r\n\r\nHe also stressed that part of his staff is dedicated to thinking about the societal impact of AI, with a special focus on retraining the existing workforce to create \u201cnot just a wealthier but also fairer society.\u201d",
    "date": "2018-01-31T14:12:54.084Z",
    "thumb": "default.png"
  }
},
{
  "model": "blog.article",
  "pk": 3,
  "fields": {
    "title": "short test",
    "slug": "short-test",
    "body": "short test text body.",
    "date": "2018-02-01T10:10:29.574Z",
    "thumb": "default.png"
  }
},
{
  "model": "blog.article",
  "pk": 4,
  "fields": {
    "title": "test 2",
    "slug": "test-2",
    "body": "image test.",
    "date": "2018-02-01T15:11:37.859Z",
    "thumb": "th2.jpg"
  }
}
]
